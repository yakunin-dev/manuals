## netfilter/iptables

- [Теория](#Цепочки)
- [Примеры](#Примеры)

### Цепочки

- **PREROUTING** — для изначальной обработки входящих пакетов
- **INPUT** — для входящих пакетов, адресованных непосредственно локальному компьютеру
- **FORWARD** — для проходящих (маршрутизируемых) пакетов
- **OUTPUT** — для пакетов, создаваемых локальным компьютером (исходящих)
- **POSTROUTING** — для окончательной обработки исходящих пакетов

### Основные действия

- **ACCEPT** - пакет покидает данную цепочку и передается в следующую.
- **DROP** - отбросить удовлетворяющий условию пакет, при этом пакет не передается в другие таблицы/цепочки.
- **REJECT** - отбросить пакет, отправив отправителю ICMP-сообщение, при этом пакет не передается в другие таблицы/цепочки.
- **RETURN** - возвратить пакет в предыдущую цепочку и продолжить ее прохождение начиная со следующего правила.
- **SNAT** - применить трансляцию адреса источника в пакете. Может использоваться только в цепочках POSTROUTING и OUTPUT в таблицах nat.
- **DNAT** - применить трансляцию адреса назначения в пакете. Может использоваться в цепочке PREROUTING в таблице nat. (в исключительных случаях - в цепочке OUTPUT)
- **LOG** - протоколировать пакет (отправляется демону syslog) и обработать остальными правилами.
- **MASQUERADE** — используется вместо SNAT при наличии соединения с динамическим IP (допускается указывать только в цепочке POSTROUTING таблицы nat).
- **MARK** — используется для установки меток на пакеты, передается для обработки дальнейшим правилам.

### Состояния в пространстве пользователя

- **NEW** - Признак NEW сообщает о том, что пакет является первым для данного соединения. Это означает, что это первый пакет в данном соединении, который увидел модуль трассировщика. Например если получен SYN пакет являющийся первым пакетом для данного соединения, то он получит статус NEW. Однако, пакет может и не быть SYN пакетом и тем не менее получить статус NEW. Это может породить определенные проблемы в отдельных случаях, но может оказаться и весьма полезным, например когда желательно "подхватить" соединения, "потерянные" другими брандмауэрами или в случаях, когда таймаут соединения уже истек, но само соединение не было закрыто.
- **RELATED** Состояние RELATED одно из самых "хитрых". Соединение получает статус RELATED если оно связано с другим соединением, имеющим признак ESTABLISHED. Это означает, что соединение получает признак RELATED тогда, когда оно инициировано из уже установленного соединения, имеющего признак ESTABLISHED. Хорошим примером соединения, которое может рассматриваться как RELATED, является соединение FTP-data, которое является связанным с портом FTP control, а так же DCC соединение, запущенное из IRC. Обратите внимание на то, что большинство протоколов TCP и некоторые из протоколов UDP весьма сложны и передают информацию о соединении через область данных TCP или UDP пакетов и поэтому требуют наличия специальных вспомогательных модулей для корректной работы.
- **ESTABLISHED** Состояние ESTABLISHED говорит о том, что это не первый пакет в соединении. Схема установки состояния ESTABLISHED достаточна проста для понимания. Единственное требование, предъявляемое к соединению, заключается в том, что для перехода в состояние ESTABLISHED необходимо чтобы узел сети передал пакет и получил на него ответ от другого узла (хоста). После получения ответа состояние соединения NEW или RELATEDбудет изаменено на ESTABLISHED.
- **INVALID** Признак INVALID говорит о том, что пакет не может быть идентифицирован и поэтому не может иметь определенного статуса. Это может происходить по разным причинам, например при нехватке памяти или при получении ICMP-сообщения об ошибке, которое не соответствует какому либо известному соединению. Наверное наилучшим вариантом было бы применение действия DROP к таким пакетам.

### Таймауты по умолчанию

| Состояние | Время ожидания |
|-----------|----------------|
| NONE | 30 минут |
| ESTABLISHED | 5 дней |
| SYN_SENT | 2 минуты |
| SYN_RECV | 60 секунд |
| FIN_WAIT | 2 минуты |
| TIME_WAIT | 2 минуты |
| CLOSE	 | 10 секунд |
| CLOSE_WAIT | 12 часов |
| LAST_ACK | 30 секунд |
| LISTEN | 2 минуты |


### Примеры

Лучшим способом начать работу с iptables это установить параметры фильтра на запрещающее все. И разрешать по мере необходимости те порты и сервисы которые необходимы в работе. Команда ```iptables -L -v -n``` покажет текущее состояние цепочек и правил.
Простая конфигурация:

```bash

#!/bin/sh
IPT="/sbin/iptables"

# Сбрасываем все установелнные до начала работы правила, цепочки и очищаем таблицу NAT

$IPT -F
$IPT -X
$IPT -t nat -F
$IPT -t nat -X
$IPT -t mangle -F
$IPT -t mangle -X

# Задаем политики по-умолчанию. Изначально все запрещено, разрешаем только то что необходимо. 
$IPT -P INPUT DROP
$IPT -P OUTPUT DROP
$IPT -P FORWARD DROP

# Зазрешаем трафик на петлевом интерфейсе.
$IPT -A INPUT -i lo -s 127.0.0.1 -d 127.0.0.1 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT

# Разрешаем подлючаться к хосту по SSH
$IPT -A INPUT -p tcp --dport 22 -j ACCEPT

# Разрешаем все виды эхо-запросов, в будущем лучше ограничить данный параметр только необходимыми пакетами.
$IPT -A INPUT -p icmp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
# iptables -A INPUT -p icmp --icmp-type 8 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT

# Разрешаем все уже установленные соединения, разрешаются только установленные не новые.
$IPT -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Разрешаем DNS запросы
$IPT -A INPUT -p udp --sport 53 -m state --state ESTABLISHED -j ACCEPT
$IPT -A INPUT -p tcp --sport 53 -m state --state ESTABLISHED -j ACCEPT

# Разрешаем все исходящие от нас соединения.
$IPT -A OUTPUT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT

```

Простой шлюз на debian-like дистрибутиве с использованием iptables. Для начала необходимо сказать ядру о том, что наши пакеты будут маршрутизированы. Для этого необходимо выполнить команду ``` echo 1 > /proc/sys/net/ipv4/ip_forward ```
либо внести изменения в файл ```nano /etc/sysctl.conf``` раскоменнтировав там или добавив если её нет строку ```net.ipv4.ip_forward=1```. Посмотреть текущие состояния можно командой ```sysctl -p```
